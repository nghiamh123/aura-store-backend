'use strict';

var clientS3 = require('@aws-sdk/client-s3');
var utilFormatUrl = require('@aws-sdk/util-format-url');
var middlewareEndpoint = require('@smithy/middleware-endpoint');
var signatureV4 = require('@smithy/signature-v4');
var utilHexEncoding = require('@smithy/util-hex-encoding');
var utilUtf8 = require('@smithy/util-utf8');

const ALGORITHM_QUERY_PARAM = "X-Amz-Algorithm";
const CREDENTIAL_QUERY_PARAM = "X-Amz-Credential";
const AMZ_DATE_QUERY_PARAM = "X-Amz-Date";
const TOKEN_QUERY_PARAM = "X-Amz-Security-Token";
const SIGNATURE_QUERY_PARAM = "X-Amz-Signature";
const ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256";

const createPresignedPost = async (client, { Bucket, Key, Conditions = [], Fields = {}, Expires = 3600 }) => {
    const { systemClockOffset, base64Encoder, utf8Decoder, sha256 } = client.config;
    const now = new Date(Date.now() + systemClockOffset);
    const signingDate = iso8601(now).replace(/[\-:]/g, "");
    const shortDate = signingDate.slice(0, 8);
    const clientRegion = await client.config.region();
    const credentialScope = signatureV4.createScope(shortDate, clientRegion, "s3");
    const clientCredentials = await client.config.credentials();
    const credential = `${clientCredentials.accessKeyId}/${credentialScope}`;
    const fields = {
        ...Fields,
        bucket: Bucket,
        [ALGORITHM_QUERY_PARAM]: ALGORITHM_IDENTIFIER,
        [CREDENTIAL_QUERY_PARAM]: credential,
        [AMZ_DATE_QUERY_PARAM]: signingDate,
        ...(clientCredentials.sessionToken ? { [TOKEN_QUERY_PARAM]: clientCredentials.sessionToken } : {}),
    };
    const expiration = new Date(now.valueOf() + Expires * 1000);
    const conditionsSet = new Set();
    for (const condition of Conditions) {
        const stringifiedCondition = JSON.stringify(condition);
        conditionsSet.add(stringifiedCondition);
    }
    for (const [k, v] of Object.entries(fields)) {
        conditionsSet.add(JSON.stringify({ [k]: v }));
    }
    if (Key.endsWith("${filename}")) {
        conditionsSet.add(JSON.stringify(["starts-with", "$key", Key.substring(0, Key.lastIndexOf("${filename}"))]));
    }
    else {
        conditionsSet.add(JSON.stringify({ key: Key }));
    }
    const conditions = Array.from(conditionsSet).map((item) => JSON.parse(item));
    const encodedPolicy = base64Encoder(utf8Decoder(JSON.stringify({
        expiration: iso8601(expiration),
        conditions,
    })));
    const signingKey = await signatureV4.getSigningKey(sha256, clientCredentials, shortDate, clientRegion, "s3");
    const signature = await hmac(sha256, signingKey, encodedPolicy);
    const endpoint = middlewareEndpoint.toEndpointV1(await middlewareEndpoint.getEndpointFromInstructions({ Bucket, Key }, clientS3.PutObjectCommand, {
        ...client.config,
    }, {
        logger: client.config.logger,
    }));
    return {
        url: utilFormatUrl.formatUrl(endpoint),
        fields: {
            ...fields,
            key: Key,
            Policy: encodedPolicy,
            [SIGNATURE_QUERY_PARAM]: utilHexEncoding.toHex(signature),
        },
    };
};
const iso8601 = (date) => date.toISOString().replace(/\.\d{3}Z$/, "Z");
const hmac = (ctor, secret, data) => {
    const hash = new ctor(secret);
    hash.update(utilUtf8.toUint8Array(data));
    return hash.digest();
};

exports.createPresignedPost = createPresignedPost;
